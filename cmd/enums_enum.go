// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.1

// Built By: go install

package main

import (
	"errors"
	"fmt"
)

const (
	// AccessLevelNone is a AccessLevel of type None.
	AccessLevelNone AccessLevel = 0
	// AccessLevelRehabber is a AccessLevel of type Rehabber.
	AccessLevelRehabber AccessLevel = 1
	// AccessLevelCoordinator is a AccessLevel of type Coordinator.
	AccessLevelCoordinator AccessLevel = 2
	// AccessLevelAdmin is a AccessLevel of type Admin.
	AccessLevelAdmin AccessLevel = 3
)

var ErrInvalidAccessLevel = errors.New("not a valid AccessLevel")

const _AccessLevelName = "NoneRehabberCoordinatorAdmin"

// AccessLevelValues returns a list of the values for AccessLevel
func AccessLevelValues() []AccessLevel {
	return []AccessLevel{
		AccessLevelNone,
		AccessLevelRehabber,
		AccessLevelCoordinator,
		AccessLevelAdmin,
	}
}

var _AccessLevelMap = map[AccessLevel]string{
	AccessLevelNone:        _AccessLevelName[0:4],
	AccessLevelRehabber:    _AccessLevelName[4:12],
	AccessLevelCoordinator: _AccessLevelName[12:23],
	AccessLevelAdmin:       _AccessLevelName[23:28],
}

// String implements the Stringer interface.
func (x AccessLevel) String() string {
	if str, ok := _AccessLevelMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AccessLevel(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AccessLevel) IsValid() bool {
	_, ok := _AccessLevelMap[x]
	return ok
}

var _AccessLevelValue = map[string]AccessLevel{
	_AccessLevelName[0:4]:   AccessLevelNone,
	_AccessLevelName[4:12]:  AccessLevelRehabber,
	_AccessLevelName[12:23]: AccessLevelCoordinator,
	_AccessLevelName[23:28]: AccessLevelAdmin,
}

// ParseAccessLevel attempts to convert a string to a AccessLevel.
func ParseAccessLevel(name string) (AccessLevel, error) {
	if x, ok := _AccessLevelValue[name]; ok {
		return x, nil
	}
	return AccessLevel(0), fmt.Errorf("%s is %w", name, ErrInvalidAccessLevel)
}

const (
	// AvailabilityAvailableIndefinitely is a Availability of type AvailableIndefinitely.
	AvailabilityAvailableIndefinitely Availability = 0
	// AvailabilityAvailableUntil is a Availability of type AvailableUntil.
	AvailabilityAvailableUntil Availability = 1
	// AvailabilityUnavailableUntil is a Availability of type UnavailableUntil.
	AvailabilityUnavailableUntil Availability = 2
	// AvailabilityUnavailableIndefinitely is a Availability of type UnavailableIndefinitely.
	AvailabilityUnavailableIndefinitely Availability = 3
)

var ErrInvalidAvailability = errors.New("not a valid Availability")

const _AvailabilityName = "AvailableIndefinitelyAvailableUntilUnavailableUntilUnavailableIndefinitely"

// AvailabilityValues returns a list of the values for Availability
func AvailabilityValues() []Availability {
	return []Availability{
		AvailabilityAvailableIndefinitely,
		AvailabilityAvailableUntil,
		AvailabilityUnavailableUntil,
		AvailabilityUnavailableIndefinitely,
	}
}

var _AvailabilityMap = map[Availability]string{
	AvailabilityAvailableIndefinitely:   _AvailabilityName[0:21],
	AvailabilityAvailableUntil:          _AvailabilityName[21:35],
	AvailabilityUnavailableUntil:        _AvailabilityName[35:51],
	AvailabilityUnavailableIndefinitely: _AvailabilityName[51:74],
}

// String implements the Stringer interface.
func (x Availability) String() string {
	if str, ok := _AvailabilityMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Availability(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Availability) IsValid() bool {
	_, ok := _AvailabilityMap[x]
	return ok
}

var _AvailabilityValue = map[string]Availability{
	_AvailabilityName[0:21]:  AvailabilityAvailableIndefinitely,
	_AvailabilityName[21:35]: AvailabilityAvailableUntil,
	_AvailabilityName[35:51]: AvailabilityUnavailableUntil,
	_AvailabilityName[51:74]: AvailabilityUnavailableIndefinitely,
}

// ParseAvailability attempts to convert a string to a Availability.
func ParseAvailability(name string) (Availability, error) {
	if x, ok := _AvailabilityValue[name]; ok {
		return x, nil
	}
	return Availability(0), fmt.Errorf("%s is %w", name, ErrInvalidAvailability)
}

const (
	// CapViewAllActivePatients is a Cap of type ViewAllActivePatients.
	CapViewAllActivePatients Cap = 0
	// CapViewAllFormerPatients is a Cap of type ViewAllFormerPatients.
	CapViewAllFormerPatients Cap = 1
	// CapViewAllHomes is a Cap of type ViewAllHomes.
	CapViewAllHomes Cap = 2
	// CapViewAllUsers is a Cap of type ViewAllUsers.
	CapViewAllUsers Cap = 3
	// CapViewCalendar is a Cap of type ViewCalendar.
	CapViewCalendar Cap = 4
	// CapSearch is a Cap of type Search.
	CapSearch Cap = 5
	// CapSetOwnPreferences is a Cap of type SetOwnPreferences.
	CapSetOwnPreferences Cap = 6
	// CapCheckInPatient is a Cap of type CheckInPatient.
	CapCheckInPatient Cap = 7
	// CapManageOwnPatients is a Cap of type ManageOwnPatients.
	CapManageOwnPatients Cap = 8
	// CapManageAllPatients is a Cap of type ManageAllPatients.
	CapManageAllPatients Cap = 9
	// CapManageOwnHomes is a Cap of type ManageOwnHomes.
	CapManageOwnHomes Cap = 10
	// CapManageAllHomes is a Cap of type ManageAllHomes.
	CapManageAllHomes Cap = 11
	// CapCreatePatientJournal is a Cap of type CreatePatientJournal.
	CapCreatePatientJournal Cap = 12
	// CapManageSpecies is a Cap of type ManageSpecies.
	CapManageSpecies Cap = 13
	// CapManageUsers is a Cap of type ManageUsers.
	CapManageUsers Cap = 14
	// CapDeleteUsers is a Cap of type DeleteUsers.
	CapDeleteUsers Cap = 15
	// CapViewAdminTools is a Cap of type ViewAdminTools.
	CapViewAdminTools Cap = 16
	// CapViewGDriveSettings is a Cap of type ViewGDriveSettings.
	CapViewGDriveSettings Cap = 17
	// CapInviteToGDrive is a Cap of type InviteToGDrive.
	CapInviteToGDrive Cap = 18
	// CapInviteToBino is a Cap of type InviteToBino.
	CapInviteToBino Cap = 19
	// CapUseImportTool is a Cap of type UseImportTool.
	CapUseImportTool Cap = 20
	// CapDebug is a Cap of type Debug.
	CapDebug Cap = 21
	// CapUploadFile is a Cap of type UploadFile.
	CapUploadFile Cap = 22
	// CapEditWiki is a Cap of type EditWiki.
	CapEditWiki Cap = 23
)

var ErrInvalidCap = errors.New("not a valid Cap")

const _CapName = "ViewAllActivePatientsViewAllFormerPatientsViewAllHomesViewAllUsersViewCalendarSearchSetOwnPreferencesCheckInPatientManageOwnPatientsManageAllPatientsManageOwnHomesManageAllHomesCreatePatientJournalManageSpeciesManageUsersDeleteUsersViewAdminToolsViewGDriveSettingsInviteToGDriveInviteToBinoUseImportToolDebugUploadFileEditWiki"

// CapValues returns a list of the values for Cap
func CapValues() []Cap {
	return []Cap{
		CapViewAllActivePatients,
		CapViewAllFormerPatients,
		CapViewAllHomes,
		CapViewAllUsers,
		CapViewCalendar,
		CapSearch,
		CapSetOwnPreferences,
		CapCheckInPatient,
		CapManageOwnPatients,
		CapManageAllPatients,
		CapManageOwnHomes,
		CapManageAllHomes,
		CapCreatePatientJournal,
		CapManageSpecies,
		CapManageUsers,
		CapDeleteUsers,
		CapViewAdminTools,
		CapViewGDriveSettings,
		CapInviteToGDrive,
		CapInviteToBino,
		CapUseImportTool,
		CapDebug,
		CapUploadFile,
		CapEditWiki,
	}
}

var _CapMap = map[Cap]string{
	CapViewAllActivePatients: _CapName[0:21],
	CapViewAllFormerPatients: _CapName[21:42],
	CapViewAllHomes:          _CapName[42:54],
	CapViewAllUsers:          _CapName[54:66],
	CapViewCalendar:          _CapName[66:78],
	CapSearch:                _CapName[78:84],
	CapSetOwnPreferences:     _CapName[84:101],
	CapCheckInPatient:        _CapName[101:115],
	CapManageOwnPatients:     _CapName[115:132],
	CapManageAllPatients:     _CapName[132:149],
	CapManageOwnHomes:        _CapName[149:163],
	CapManageAllHomes:        _CapName[163:177],
	CapCreatePatientJournal:  _CapName[177:197],
	CapManageSpecies:         _CapName[197:210],
	CapManageUsers:           _CapName[210:221],
	CapDeleteUsers:           _CapName[221:232],
	CapViewAdminTools:        _CapName[232:246],
	CapViewGDriveSettings:    _CapName[246:264],
	CapInviteToGDrive:        _CapName[264:278],
	CapInviteToBino:          _CapName[278:290],
	CapUseImportTool:         _CapName[290:303],
	CapDebug:                 _CapName[303:308],
	CapUploadFile:            _CapName[308:318],
	CapEditWiki:              _CapName[318:326],
}

// String implements the Stringer interface.
func (x Cap) String() string {
	if str, ok := _CapMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Cap(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Cap) IsValid() bool {
	_, ok := _CapMap[x]
	return ok
}

var _CapValue = map[string]Cap{
	_CapName[0:21]:    CapViewAllActivePatients,
	_CapName[21:42]:   CapViewAllFormerPatients,
	_CapName[42:54]:   CapViewAllHomes,
	_CapName[54:66]:   CapViewAllUsers,
	_CapName[66:78]:   CapViewCalendar,
	_CapName[78:84]:   CapSearch,
	_CapName[84:101]:  CapSetOwnPreferences,
	_CapName[101:115]: CapCheckInPatient,
	_CapName[115:132]: CapManageOwnPatients,
	_CapName[132:149]: CapManageAllPatients,
	_CapName[149:163]: CapManageOwnHomes,
	_CapName[163:177]: CapManageAllHomes,
	_CapName[177:197]: CapCreatePatientJournal,
	_CapName[197:210]: CapManageSpecies,
	_CapName[210:221]: CapManageUsers,
	_CapName[221:232]: CapDeleteUsers,
	_CapName[232:246]: CapViewAdminTools,
	_CapName[246:264]: CapViewGDriveSettings,
	_CapName[264:278]: CapInviteToGDrive,
	_CapName[278:290]: CapInviteToBino,
	_CapName[290:303]: CapUseImportTool,
	_CapName[303:308]: CapDebug,
	_CapName[308:318]: CapUploadFile,
	_CapName[318:326]: CapEditWiki,
}

// ParseCap attempts to convert a string to a Cap.
func ParseCap(name string) (Cap, error) {
	if x, ok := _CapValue[name]; ok {
		return x, nil
	}
	return Cap(0), fmt.Errorf("%s is %w", name, ErrInvalidCap)
}

const (
	// EventUnknown is a Event of type Unknown.
	EventUnknown Event = 0
	// EventRegistered is a Event of type Registered.
	EventRegistered Event = 1
	// EventAdopted is a Event of type Adopted.
	EventAdopted Event = 3
	// EventReleased is a Event of type Released.
	EventReleased Event = 4
	// EventTransferredToOtherHome is a Event of type TransferredToOtherHome.
	EventTransferredToOtherHome Event = 5
	// EventTransferredOutsideOrganization is a Event of type TransferredOutsideOrganization.
	EventTransferredOutsideOrganization Event = 6
	// EventDied is a Event of type Died.
	EventDied Event = 7
	// EventEuthanized is a Event of type Euthanized.
	EventEuthanized Event = 8
	// EventStatusChanged is a Event of type StatusChanged.
	// Associated ID is status
	EventStatusChanged Event = 11
	// EventDeleted is a Event of type Deleted.
	EventDeleted Event = 12
	// EventNameChanged is a Event of type NameChanged.
	EventNameChanged Event = 13
	// EventJournalCreated is a Event of type JournalCreated.
	EventJournalCreated Event = 14
	// EventJournalAttached is a Event of type JournalAttached.
	EventJournalAttached Event = 15
	// EventJournalDetached is a Event of type JournalDetached.
	EventJournalDetached Event = 16
)

var ErrInvalidEvent = errors.New("not a valid Event")

const _EventName = "UnknownRegisteredAdoptedReleasedTransferredToOtherHomeTransferredOutsideOrganizationDiedEuthanizedStatusChangedDeletedNameChangedJournalCreatedJournalAttachedJournalDetached"

// EventValues returns a list of the values for Event
func EventValues() []Event {
	return []Event{
		EventUnknown,
		EventRegistered,
		EventAdopted,
		EventReleased,
		EventTransferredToOtherHome,
		EventTransferredOutsideOrganization,
		EventDied,
		EventEuthanized,
		EventStatusChanged,
		EventDeleted,
		EventNameChanged,
		EventJournalCreated,
		EventJournalAttached,
		EventJournalDetached,
	}
}

var _EventMap = map[Event]string{
	EventUnknown:                        _EventName[0:7],
	EventRegistered:                     _EventName[7:17],
	EventAdopted:                        _EventName[17:24],
	EventReleased:                       _EventName[24:32],
	EventTransferredToOtherHome:         _EventName[32:54],
	EventTransferredOutsideOrganization: _EventName[54:84],
	EventDied:                           _EventName[84:88],
	EventEuthanized:                     _EventName[88:98],
	EventStatusChanged:                  _EventName[98:111],
	EventDeleted:                        _EventName[111:118],
	EventNameChanged:                    _EventName[118:129],
	EventJournalCreated:                 _EventName[129:143],
	EventJournalAttached:                _EventName[143:158],
	EventJournalDetached:                _EventName[158:173],
}

// String implements the Stringer interface.
func (x Event) String() string {
	if str, ok := _EventMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Event(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Event) IsValid() bool {
	_, ok := _EventMap[x]
	return ok
}

var _EventValue = map[string]Event{
	_EventName[0:7]:     EventUnknown,
	_EventName[7:17]:    EventRegistered,
	_EventName[17:24]:   EventAdopted,
	_EventName[24:32]:   EventReleased,
	_EventName[32:54]:   EventTransferredToOtherHome,
	_EventName[54:84]:   EventTransferredOutsideOrganization,
	_EventName[84:88]:   EventDied,
	_EventName[88:98]:   EventEuthanized,
	_EventName[98:111]:  EventStatusChanged,
	_EventName[111:118]: EventDeleted,
	_EventName[118:129]: EventNameChanged,
	_EventName[129:143]: EventJournalCreated,
	_EventName[143:158]: EventJournalAttached,
	_EventName[158:173]: EventJournalDetached,
}

// ParseEvent attempts to convert a string to a Event.
func ParseEvent(name string) (Event, error) {
	if x, ok := _EventValue[name]; ok {
		return x, nil
	}
	return Event(0), fmt.Errorf("%s is %w", name, ErrInvalidEvent)
}

const (
	// FBInfo is a FB of type Info.
	FBInfo FB = 0
	// FBSuccess is a FB of type Success.
	FBSuccess FB = 1
	// FBWarning is a FB of type Warning.
	FBWarning FB = 2
	// FBError is a FB of type Error.
	FBError FB = 3
)

var ErrInvalidFB = errors.New("not a valid FB")

const _FBName = "InfoSuccessWarningError"

// FBValues returns a list of the values for FB
func FBValues() []FB {
	return []FB{
		FBInfo,
		FBSuccess,
		FBWarning,
		FBError,
	}
}

var _FBMap = map[FB]string{
	FBInfo:    _FBName[0:4],
	FBSuccess: _FBName[4:11],
	FBWarning: _FBName[11:18],
	FBError:   _FBName[18:23],
}

// String implements the Stringer interface.
func (x FB) String() string {
	if str, ok := _FBMap[x]; ok {
		return str
	}
	return fmt.Sprintf("FB(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x FB) IsValid() bool {
	_, ok := _FBMap[x]
	return ok
}

var _FBValue = map[string]FB{
	_FBName[0:4]:   FBInfo,
	_FBName[4:11]:  FBSuccess,
	_FBName[11:18]: FBWarning,
	_FBName[18:23]: FBError,
}

// ParseFB attempts to convert a string to a FB.
func ParseFB(name string) (FB, error) {
	if x, ok := _FBValue[name]; ok {
		return x, nil
	}
	return FB(0), fmt.Errorf("%s is %w", name, ErrInvalidFB)
}

const (
	// FileAccessibilityPersonal is a FileAccessibility of type Personal.
	FileAccessibilityPersonal FileAccessibility = 0
	// FileAccessibilityInternal is a FileAccessibility of type Internal.
	FileAccessibilityInternal FileAccessibility = 1
	// FileAccessibilityPublic is a FileAccessibility of type Public.
	FileAccessibilityPublic FileAccessibility = 2
)

var ErrInvalidFileAccessibility = errors.New("not a valid FileAccessibility")

const _FileAccessibilityName = "PersonalInternalPublic"

// FileAccessibilityValues returns a list of the values for FileAccessibility
func FileAccessibilityValues() []FileAccessibility {
	return []FileAccessibility{
		FileAccessibilityPersonal,
		FileAccessibilityInternal,
		FileAccessibilityPublic,
	}
}

var _FileAccessibilityMap = map[FileAccessibility]string{
	FileAccessibilityPersonal: _FileAccessibilityName[0:8],
	FileAccessibilityInternal: _FileAccessibilityName[8:16],
	FileAccessibilityPublic:   _FileAccessibilityName[16:22],
}

// String implements the Stringer interface.
func (x FileAccessibility) String() string {
	if str, ok := _FileAccessibilityMap[x]; ok {
		return str
	}
	return fmt.Sprintf("FileAccessibility(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x FileAccessibility) IsValid() bool {
	_, ok := _FileAccessibilityMap[x]
	return ok
}

var _FileAccessibilityValue = map[string]FileAccessibility{
	_FileAccessibilityName[0:8]:   FileAccessibilityPersonal,
	_FileAccessibilityName[8:16]:  FileAccessibilityInternal,
	_FileAccessibilityName[16:22]: FileAccessibilityPublic,
}

// ParseFileAccessibility attempts to convert a string to a FileAccessibility.
func ParseFileAccessibility(name string) (FileAccessibility, error) {
	if x, ok := _FileAccessibilityValue[name]; ok {
		return x, nil
	}
	return FileAccessibility(0), fmt.Errorf("%s is %w", name, ErrInvalidFileAccessibility)
}

const (
	// GDriveTaskRequestIDGetFile is a GDriveTaskRequestID of type GetFile.
	GDriveTaskRequestIDGetFile GDriveTaskRequestID = 0
	// GDriveTaskRequestIDInviteUser is a GDriveTaskRequestID of type InviteUser.
	GDriveTaskRequestIDInviteUser GDriveTaskRequestID = 1
	// GDriveTaskRequestIDCreateJournal is a GDriveTaskRequestID of type CreateJournal.
	GDriveTaskRequestIDCreateJournal GDriveTaskRequestID = 2
	// GDriveTaskRequestIDListFiles is a GDriveTaskRequestID of type ListFiles.
	GDriveTaskRequestIDListFiles GDriveTaskRequestID = 3
	// GDriveTaskRequestIDUpdateJournal is a GDriveTaskRequestID of type UpdateJournal.
	GDriveTaskRequestIDUpdateJournal GDriveTaskRequestID = 4
)

var ErrInvalidGDriveTaskRequestID = errors.New("not a valid GDriveTaskRequestID")

const _GDriveTaskRequestIDName = "GetFileInviteUserCreateJournalListFilesUpdateJournal"

// GDriveTaskRequestIDValues returns a list of the values for GDriveTaskRequestID
func GDriveTaskRequestIDValues() []GDriveTaskRequestID {
	return []GDriveTaskRequestID{
		GDriveTaskRequestIDGetFile,
		GDriveTaskRequestIDInviteUser,
		GDriveTaskRequestIDCreateJournal,
		GDriveTaskRequestIDListFiles,
		GDriveTaskRequestIDUpdateJournal,
	}
}

var _GDriveTaskRequestIDMap = map[GDriveTaskRequestID]string{
	GDriveTaskRequestIDGetFile:       _GDriveTaskRequestIDName[0:7],
	GDriveTaskRequestIDInviteUser:    _GDriveTaskRequestIDName[7:17],
	GDriveTaskRequestIDCreateJournal: _GDriveTaskRequestIDName[17:30],
	GDriveTaskRequestIDListFiles:     _GDriveTaskRequestIDName[30:39],
	GDriveTaskRequestIDUpdateJournal: _GDriveTaskRequestIDName[39:52],
}

// String implements the Stringer interface.
func (x GDriveTaskRequestID) String() string {
	if str, ok := _GDriveTaskRequestIDMap[x]; ok {
		return str
	}
	return fmt.Sprintf("GDriveTaskRequestID(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x GDriveTaskRequestID) IsValid() bool {
	_, ok := _GDriveTaskRequestIDMap[x]
	return ok
}

var _GDriveTaskRequestIDValue = map[string]GDriveTaskRequestID{
	_GDriveTaskRequestIDName[0:7]:   GDriveTaskRequestIDGetFile,
	_GDriveTaskRequestIDName[7:17]:  GDriveTaskRequestIDInviteUser,
	_GDriveTaskRequestIDName[17:30]: GDriveTaskRequestIDCreateJournal,
	_GDriveTaskRequestIDName[30:39]: GDriveTaskRequestIDListFiles,
	_GDriveTaskRequestIDName[39:52]: GDriveTaskRequestIDUpdateJournal,
}

// ParseGDriveTaskRequestID attempts to convert a string to a GDriveTaskRequestID.
func ParseGDriveTaskRequestID(name string) (GDriveTaskRequestID, error) {
	if x, ok := _GDriveTaskRequestIDValue[name]; ok {
		return x, nil
	}
	return GDriveTaskRequestID(0), fmt.Errorf("%s is %w", name, ErrInvalidGDriveTaskRequestID)
}

const (
	// LanguageIDNO is a LanguageID of type NO.
	LanguageIDNO LanguageID = 1
	// LanguageIDEN is a LanguageID of type EN.
	LanguageIDEN LanguageID = 2
)

var ErrInvalidLanguageID = errors.New("not a valid LanguageID")

const _LanguageIDName = "NOEN"

// LanguageIDValues returns a list of the values for LanguageID
func LanguageIDValues() []LanguageID {
	return []LanguageID{
		LanguageIDNO,
		LanguageIDEN,
	}
}

var _LanguageIDMap = map[LanguageID]string{
	LanguageIDNO: _LanguageIDName[0:2],
	LanguageIDEN: _LanguageIDName[2:4],
}

// String implements the Stringer interface.
func (x LanguageID) String() string {
	if str, ok := _LanguageIDMap[x]; ok {
		return str
	}
	return fmt.Sprintf("LanguageID(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LanguageID) IsValid() bool {
	_, ok := _LanguageIDMap[x]
	return ok
}

var _LanguageIDValue = map[string]LanguageID{
	_LanguageIDName[0:2]: LanguageIDNO,
	_LanguageIDName[2:4]: LanguageIDEN,
}

// ParseLanguageID attempts to convert a string to a LanguageID.
func ParseLanguageID(name string) (LanguageID, error) {
	if x, ok := _LanguageIDValue[name]; ok {
		return x, nil
	}
	return LanguageID(0), fmt.Errorf("%s is %w", name, ErrInvalidLanguageID)
}

const (
	// MatchTypeJournal is a MatchType of type journal.
	MatchTypeJournal MatchType = "journal"
	// MatchTypePatient is a MatchType of type patient.
	MatchTypePatient MatchType = "patient"
)

var ErrInvalidMatchType = errors.New("not a valid MatchType")

// MatchTypeValues returns a list of the values for MatchType
func MatchTypeValues() []MatchType {
	return []MatchType{
		MatchTypeJournal,
		MatchTypePatient,
	}
}

// String implements the Stringer interface.
func (x MatchType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MatchType) IsValid() bool {
	_, err := ParseMatchType(string(x))
	return err == nil
}

var _MatchTypeValue = map[string]MatchType{
	"journal": MatchTypeJournal,
	"patient": MatchTypePatient,
}

// ParseMatchType attempts to convert a string to a MatchType.
func ParseMatchType(name string) (MatchType, error) {
	if x, ok := _MatchTypeValue[name]; ok {
		return x, nil
	}
	return MatchType(""), fmt.Errorf("%s is %w", name, ErrInvalidMatchType)
}

const (
	// TemplateYYYY is a Template of type YYYY.
	TemplateYYYY Template = "YYYY"
	// TemplateMM is a Template of type MM.
	TemplateMM Template = "MM"
	// TemplateDD is a Template of type DD.
	TemplateDD Template = "DD"
	// TemplateName is a Template of type Name.
	TemplateName Template = "Name"
	// TemplateSpecies is a Template of type Species.
	TemplateSpecies Template = "Species"
	// TemplateBinoURL is a Template of type BinoURL.
	TemplateBinoURL Template = "BinoURL"
)

var ErrInvalidTemplate = errors.New("not a valid Template")

// TemplateValues returns a list of the values for Template
func TemplateValues() []Template {
	return []Template{
		TemplateYYYY,
		TemplateMM,
		TemplateDD,
		TemplateName,
		TemplateSpecies,
		TemplateBinoURL,
	}
}

// String implements the Stringer interface.
func (x Template) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Template) IsValid() bool {
	_, err := ParseTemplate(string(x))
	return err == nil
}

var _TemplateValue = map[string]Template{
	"YYYY":    TemplateYYYY,
	"MM":      TemplateMM,
	"DD":      TemplateDD,
	"Name":    TemplateName,
	"Species": TemplateSpecies,
	"BinoURL": TemplateBinoURL,
}

// ParseTemplate attempts to convert a string to a Template.
func ParseTemplate(name string) (Template, error) {
	if x, ok := _TemplateValue[name]; ok {
		return x, nil
	}
	return Template(""), fmt.Errorf("%s is %w", name, ErrInvalidTemplate)
}

const (
	// TimePreferenceNone is a TimePreference of type None.
	TimePreferenceNone TimePreference = 0
	// TimePreferenceNewer is a TimePreference of type Newer.
	TimePreferenceNewer TimePreference = 1
	// TimePreferenceOlder is a TimePreference of type Older.
	TimePreferenceOlder TimePreference = 2
)

var ErrInvalidTimePreference = errors.New("not a valid TimePreference")

const _TimePreferenceName = "NoneNewerOlder"

// TimePreferenceValues returns a list of the values for TimePreference
func TimePreferenceValues() []TimePreference {
	return []TimePreference{
		TimePreferenceNone,
		TimePreferenceNewer,
		TimePreferenceOlder,
	}
}

var _TimePreferenceMap = map[TimePreference]string{
	TimePreferenceNone:  _TimePreferenceName[0:4],
	TimePreferenceNewer: _TimePreferenceName[4:9],
	TimePreferenceOlder: _TimePreferenceName[9:14],
}

// String implements the Stringer interface.
func (x TimePreference) String() string {
	if str, ok := _TimePreferenceMap[x]; ok {
		return str
	}
	return fmt.Sprintf("TimePreference(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TimePreference) IsValid() bool {
	_, ok := _TimePreferenceMap[x]
	return ok
}

var _TimePreferenceValue = map[string]TimePreference{
	_TimePreferenceName[0:4]:  TimePreferenceNone,
	_TimePreferenceName[4:9]:  TimePreferenceNewer,
	_TimePreferenceName[9:14]: TimePreferenceOlder,
}

// ParseTimePreference attempts to convert a string to a TimePreference.
func ParseTimePreference(name string) (TimePreference, error) {
	if x, ok := _TimePreferenceValue[name]; ok {
		return x, nil
	}
	return TimePreference(0), fmt.Errorf("%s is %w", name, ErrInvalidTimePreference)
}
