// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sql-stat-patient.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteStatPatientForDate = `-- name: DeleteStatPatientForDate :exec
DELETE FROM stat_patient WHERE date = $1
`

func (q *Queries) DeleteStatPatientForDate(ctx context.Context, date pgtype.Date) error {
	_, err := q.db.Exec(ctx, deleteStatPatientForDate, date)
	return err
}

const statPatientGetCurrentSpeciesDistribution = `-- name: StatPatientGetCurrentSpeciesDistribution :many
SELECT COALESCE(sl.name, '?'), count(sp.patient_id) AS count
FROM stat_patient AS sp
LEFT JOIN species_language AS sl
  ON sl.species_id = sp.species_id
WHERE date = (
    SELECT MAX(date)
    FROM stat_patient
) AND sl.language_id = $1
GROUP BY sl.name
ORDER BY count DESC
`

type StatPatientGetCurrentSpeciesDistributionRow struct {
	Name  string
	Count int64
}

func (q *Queries) StatPatientGetCurrentSpeciesDistribution(ctx context.Context, languageID int32) ([]StatPatientGetCurrentSpeciesDistributionRow, error) {
	rows, err := q.db.Query(ctx, statPatientGetCurrentSpeciesDistribution, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatPatientGetCurrentSpeciesDistributionRow
	for rows.Next() {
		var i StatPatientGetCurrentSpeciesDistributionRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statPatientGetCurrentTotalCount = `-- name: StatPatientGetCurrentTotalCount :one
SELECT count(*) AS count
FROM stat_patient
WHERE date = $1
`

func (q *Queries) StatPatientGetCurrentTotalCount(ctx context.Context, date pgtype.Date) (int64, error) {
	row := q.db.QueryRow(ctx, statPatientGetCurrentTotalCount, date)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const statPatientGetSpeciesDistributionOverTime = `-- name: StatPatientGetSpeciesDistributionOverTime :many
SELECT date, COALESCE(sl.name, '?'), count(sp.patient_id) AS count
FROM stat_patient AS sp
LEFT JOIN species_language AS sl
  ON sl.species_id = sp.species_id
WHERE date >= $1 AND date <= $2 AND sl.language_id = $3
GROUP BY date, sl.name
ORDER BY date
`

type StatPatientGetSpeciesDistributionOverTimeParams struct {
	FirstDate  pgtype.Date
	LastDate   pgtype.Date
	LanguageID int32
}

type StatPatientGetSpeciesDistributionOverTimeRow struct {
	Date  pgtype.Date
	Name  string
	Count int64
}

func (q *Queries) StatPatientGetSpeciesDistributionOverTime(ctx context.Context, arg StatPatientGetSpeciesDistributionOverTimeParams) ([]StatPatientGetSpeciesDistributionOverTimeRow, error) {
	rows, err := q.db.Query(ctx, statPatientGetSpeciesDistributionOverTime, arg.FirstDate, arg.LastDate, arg.LanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatPatientGetSpeciesDistributionOverTimeRow
	for rows.Next() {
		var i StatPatientGetSpeciesDistributionOverTimeRow
		if err := rows.Scan(&i.Date, &i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statPatientGetSpeciesDistributionOverTimeForHome = `-- name: StatPatientGetSpeciesDistributionOverTimeForHome :many
SELECT date, species_id, count(patient_id)
FROM stat_patient
WHERE date >= $1 AND date <= $2 AND home_id=@home_id
GROUP BY species_id, date
`

type StatPatientGetSpeciesDistributionOverTimeForHomeParams struct {
	FirstDate pgtype.Date
	LastDate  pgtype.Date
}

type StatPatientGetSpeciesDistributionOverTimeForHomeRow struct {
	Date      pgtype.Date
	SpeciesID int32
	Count     int64
}

func (q *Queries) StatPatientGetSpeciesDistributionOverTimeForHome(ctx context.Context, arg StatPatientGetSpeciesDistributionOverTimeForHomeParams) ([]StatPatientGetSpeciesDistributionOverTimeForHomeRow, error) {
	rows, err := q.db.Query(ctx, statPatientGetSpeciesDistributionOverTimeForHome, arg.FirstDate, arg.LastDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatPatientGetSpeciesDistributionOverTimeForHomeRow
	for rows.Next() {
		var i StatPatientGetSpeciesDistributionOverTimeForHomeRow
		if err := rows.Scan(&i.Date, &i.SpeciesID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statPatientInsert = `-- name: StatPatientInsert :execrows
INSERT INTO stat_patient (date, species_id, home_id, patient_id)
SELECT
  $1::date,
  s.species_id,
  h.home_id,
  p.patient_id
FROM unnest($2::int[]) WITH ORDINALITY AS s(species_id, ord)
JOIN unnest($3::int[])    WITH ORDINALITY AS h(home_id, ord)
  USING (ord)
JOIN unnest($4::int[])      WITH ORDINALITY AS p(patient_id, ord)
  USING (ord)
`

type StatPatientInsertParams struct {
	Date      pgtype.Date
	SpeciesID []int32
	HomeID    []int32
	PatientID []int32
}

func (q *Queries) StatPatientInsert(ctx context.Context, arg StatPatientInsertParams) (int64, error) {
	result, err := q.db.Exec(ctx, statPatientInsert,
		arg.Date,
		arg.SpeciesID,
		arg.HomeID,
		arg.PatientID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
