// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sql-search.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteSearchEntriesByGoogleID = `-- name: DeleteSearchEntriesByGoogleID :exec
DELETE FROM journal
WHERE google_id = $1
`

func (q *Queries) DeleteSearchEntriesByGoogleID(ctx context.Context, googleID string) error {
	_, err := q.db.Exec(ctx, deleteSearchEntriesByGoogleID, googleID)
	return err
}

const searchAdvanced = `-- name: SearchAdvanced :many
WITH q AS (
  SELECT websearch_to_tsquery($8::regconfig, $9::text) AS qry
)
SELECT
  i.google_id, i.r_fts_header, i.r_fts_body, i.r_sim_header, i.r_sim_body, i.r_ilike_header, i.r_ilike_body, i.r_recency, i.header, i.body, i.header_headline, i.body_headline, i.updated,
  (
      i.r_fts_header
    + i.r_fts_body
    + i.r_sim_header
    + i.r_sim_body
    + i.r_ilike_header
    + i.r_ilike_body
    + i.r_recency
  )::real AS rank
FROM (
  SELECT
    s.google_id,
    ($1::real   * ts_rank(s.fts_header, q.qry))::real AS r_fts_header,
    ($2::real     * ts_rank(s.fts_body,   q.qry))::real AS r_fts_body,
    ($3::real   * f.sim_header)::real                 AS r_sim_header,
    ($4::real     * f.sim_body)::real                   AS r_sim_body,
    ($5::real * f.ilike_header)::real               AS r_ilike_header,
    ($6::real   * f.ilike_body)::real                 AS r_ilike_body,
    ($7::real      * f.recency)::real                    AS r_recency,
    COALESCE(s.header, '') AS header,
    COALESCE(s.body, '') AS body,
    ts_headline($8::regconfig, s.header, q.qry, 'StartSel=[START],StopSel=[STOP],HighlightAll=true')::text AS header_headline,
    ts_headline($8::regconfig, s.body,   q.qry, 'StartSel=[START],StopSel=[STOP],MaxFragments=5,MinWords=3,MaxWords=10,FragmentDelimiter=[CUT]')::text AS body_headline,
    s.updated
  FROM journal s
  CROSS JOIN q
  CROSS JOIN LATERAL (
    SELECT
      similarity(lower(s.header), lower($9)) AS sim_header,
      similarity(lower(s.body),   lower($9)) AS sim_body,
      CASE WHEN s.header ILIKE ('%' || $9 || '%') THEN 1 ELSE 0 END AS ilike_header,
      CASE WHEN s.body   ILIKE ('%' || $9 || '%') THEN 1 ELSE 0 END AS ilike_body,
      exp(
        - GREATEST(0, EXTRACT(EPOCH FROM (now() - s.created))) /
          ($10::real * 86400.0)
      ) AS recency
  ) f
  WHERE journal_match_advanced(
    s,
    q.qry,
    $9,
    $11::real,
    $12::timestamptz,
    $13::timestamptz
  )
) i
ORDER BY rank DESC
LIMIT $15
OFFSET $14
`

type SearchAdvancedParams struct {
	WFtsHeader          float32
	WFtsBody            float32
	WSimHeader          float32
	WSimBody            float32
	WIlikeHeader        float32
	WIlikeBody          float32
	WRecency            float32
	Lang                string
	Query               string
	RecencyHalfLifeDays float32
	Simthreshold        float32
	MinUpdated          pgtype.Timestamptz
	MaxUpdated          pgtype.Timestamptz
	Offset              int32
	Limit               int32
}

type SearchAdvancedRow struct {
	GoogleID       string
	RFtsHeader     float32
	RFtsBody       float32
	RSimHeader     float32
	RSimBody       float32
	RIlikeHeader   float32
	RIlikeBody     float32
	RRecency       float32
	Header         string
	Body           string
	HeaderHeadline string
	BodyHeadline   string
	Updated        pgtype.Timestamptz
	Rank           float32
}

func (q *Queries) SearchAdvanced(ctx context.Context, arg SearchAdvancedParams) ([]SearchAdvancedRow, error) {
	rows, err := q.db.Query(ctx, searchAdvanced,
		arg.WFtsHeader,
		arg.WFtsBody,
		arg.WSimHeader,
		arg.WSimBody,
		arg.WIlikeHeader,
		arg.WIlikeBody,
		arg.WRecency,
		arg.Lang,
		arg.Query,
		arg.RecencyHalfLifeDays,
		arg.Simthreshold,
		arg.MinUpdated,
		arg.MaxUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAdvancedRow
	for rows.Next() {
		var i SearchAdvancedRow
		if err := rows.Scan(
			&i.GoogleID,
			&i.RFtsHeader,
			&i.RFtsBody,
			&i.RSimHeader,
			&i.RSimBody,
			&i.RIlikeHeader,
			&i.RIlikeBody,
			&i.RRecency,
			&i.Header,
			&i.Body,
			&i.HeaderHeadline,
			&i.BodyHeadline,
			&i.Updated,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAdvancedCount = `-- name: SearchAdvancedCount :one
WITH q AS (
  SELECT websearch_to_tsquery($5::regconfig, $1::text) AS qry
)
SELECT COUNT(*)::int AS n
FROM journal s
CROSS JOIN q
WHERE journal_match_advanced(
  s,
  q.qry,
  $1,
  $2::real,
  $3::timestamptz,
  $4::timestamptz
)
`

type SearchAdvancedCountParams struct {
	Query        string
	Simthreshold float32
	MinUpdated   pgtype.Timestamptz
	MaxUpdated   pgtype.Timestamptz
	Lang         string
}

func (q *Queries) SearchAdvancedCount(ctx context.Context, arg SearchAdvancedCountParams) (int32, error) {
	row := q.db.QueryRow(ctx, searchAdvancedCount,
		arg.Query,
		arg.Simthreshold,
		arg.MinUpdated,
		arg.MaxUpdated,
		arg.Lang,
	)
	var n int32
	err := row.Scan(&n)
	return n, err
}

const searchBasic = `-- name: SearchBasic :many
WITH q AS (
  SELECT websearch_to_tsquery($3::regconfig, $6::text) AS qry
)
SELECT
  i.r_fts_header, i.r_fts_body, i.header_headline, i.body_headline, i.header, i.google_id, i.updated, i.parent_google_id, i.parent_folder_name, i.patient_id,
  (
      i.r_fts_header
    + i.r_fts_body
  )::real AS rank
FROM (
  SELECT
    ($1::real   * ts_rank(s.fts_header, q.qry))::real AS r_fts_header,
    ($2::real     * ts_rank(s.fts_body,   q.qry))::real AS r_fts_body,
    ts_headline($3::regconfig, s.header, q.qry, 'StartSel=[START],StopSel=[STOP],HighlightAll=true')::text AS header_headline,
    ts_headline($3::regconfig, s.body,   q.qry, 'StartSel=[START],StopSel=[STOP],MaxFragments=5,MinWords=3,MaxWords=10,FragmentDelimiter=[CUT]')::text AS body_headline,
    s.header,
    s.google_id,
    s.updated,
    s.parent_google_id,
    gf.name AS parent_folder_name,
    p.id AS patient_id
  FROM journal s
  LEFT JOIN google_folder gf ON gf.google_id = s.parent_google_id
  LEFT JOIN patient p ON p.google_id = s.google_id
  CROSS JOIN q WHERE journal_match_basic(s, q.qry)
) i
ORDER BY rank DESC
LIMIT $5
OFFSET $4
`

type SearchBasicParams struct {
	WFtsHeader float32
	WFtsBody   float32
	Lang       string
	Offset     int32
	Limit      int32
	Query      string
}

type SearchBasicRow struct {
	RFtsHeader       float32
	RFtsBody         float32
	HeaderHeadline   string
	BodyHeadline     string
	Header           pgtype.Text
	GoogleID         string
	Updated          pgtype.Timestamptz
	ParentGoogleID   pgtype.Text
	ParentFolderName pgtype.Text
	PatientID        pgtype.Int4
	Rank             float32
}

func (q *Queries) SearchBasic(ctx context.Context, arg SearchBasicParams) ([]SearchBasicRow, error) {
	rows, err := q.db.Query(ctx, searchBasic,
		arg.WFtsHeader,
		arg.WFtsBody,
		arg.Lang,
		arg.Offset,
		arg.Limit,
		arg.Query,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchBasicRow
	for rows.Next() {
		var i SearchBasicRow
		if err := rows.Scan(
			&i.RFtsHeader,
			&i.RFtsBody,
			&i.HeaderHeadline,
			&i.BodyHeadline,
			&i.Header,
			&i.GoogleID,
			&i.Updated,
			&i.ParentGoogleID,
			&i.ParentFolderName,
			&i.PatientID,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBasicCount = `-- name: SearchBasicCount :one
WITH q AS (
  SELECT websearch_to_tsquery($1::regconfig, $2::text) AS qry
)
SELECT COUNT(*)::int AS n
FROM journal s
CROSS JOIN q
WHERE journal_match_basic(s, q.qry)
`

type SearchBasicCountParams struct {
	Lang  string
	Query string
}

func (q *Queries) SearchBasicCount(ctx context.Context, arg SearchBasicCountParams) (int32, error) {
	row := q.db.QueryRow(ctx, searchBasicCount, arg.Lang, arg.Query)
	var n int32
	err := row.Scan(&n)
	return n, err
}
