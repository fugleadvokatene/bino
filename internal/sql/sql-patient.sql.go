// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sql-patient.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const acceptSuggestedJournal = `-- name: AcceptSuggestedJournal :exec
UPDATE patient
SET journal_url = suggested_journal_url, suggested_journal_title = '', suggested_journal_url = ''
WHERE id = $1
  AND suggested_journal_url IS NOT NULL
`

func (q *Queries) AcceptSuggestedJournal(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, acceptSuggestedJournal, id)
	return err
}

const addPatient = `-- name: AddPatient :one
INSERT INTO patient (species_id, name, curr_home_id, status, time_checkin, journal_pending)
VALUES ($1, $2, $3, $4, NOW(), $5)
RETURNING id
`

type AddPatientParams struct {
	SpeciesID      int32
	Name           string
	CurrHomeID     pgtype.Int4
	Status         int32
	JournalPending bool
}

func (q *Queries) AddPatient(ctx context.Context, arg AddPatientParams) (int32, error) {
	row := q.db.QueryRow(ctx, addPatient,
		arg.SpeciesID,
		arg.Name,
		arg.CurrHomeID,
		arg.Status,
		arg.JournalPending,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addPatients = `-- name: AddPatients :many
INSERT INTO patient (species_id, name, curr_home_id, status, journal_url, time_checkin)
SELECT UNNEST($1::int[]),
       UNNEST($2::text[]),
       UNNEST($3::int[]),
       UNNEST($4::int[]),
       UNNEST($5::text[]),
       NOW()
RETURNING id
`

type AddPatientsParams struct {
	Species    []int32
	Name       []string
	CurrHomeID []int32
	Status     []int32
	JournalUrl []string
}

func (q *Queries) AddPatients(ctx context.Context, arg AddPatientsParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, addPatients,
		arg.Species,
		arg.Name,
		arg.CurrHomeID,
		arg.Status,
		arg.JournalUrl,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const associateFileWithPatient = `-- name: AssociateFileWithPatient :exec
INSERT INTO file_patient (file_id, patient_id)
VALUES ($1, $2)
`

type AssociateFileWithPatientParams struct {
	FileID    int32
	PatientID int32
}

func (q *Queries) AssociateFileWithPatient(ctx context.Context, arg AssociateFileWithPatientParams) error {
	_, err := q.db.Exec(ctx, associateFileWithPatient, arg.FileID, arg.PatientID)
	return err
}

const checkoutPatient = `-- name: CheckoutPatient :exec
UPDATE patient
SET time_checkout = $2
WHERE id = $1
`

type CheckoutPatientParams struct {
	ID           int32
	TimeCheckout pgtype.Timestamptz
}

func (q *Queries) CheckoutPatient(ctx context.Context, arg CheckoutPatientParams) error {
	_, err := q.db.Exec(ctx, checkoutPatient, arg.ID, arg.TimeCheckout)
	return err
}

const declineSuggestedJournal = `-- name: DeclineSuggestedJournal :exec
UPDATE patient
SET suggested_journal_url = '', suggested_journal_title = ''
WHERE id = $1
`

func (q *Queries) DeclineSuggestedJournal(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, declineSuggestedJournal, id)
	return err
}

const deleteFileAssociationsForPatient = `-- name: DeleteFileAssociationsForPatient :exec
DELETE FROM file_patient
WHERE patient_id = $1
`

func (q *Queries) DeleteFileAssociationsForPatient(ctx context.Context, patientID int32) error {
	_, err := q.db.Exec(ctx, deleteFileAssociationsForPatient, patientID)
	return err
}

const deletePatient = `-- name: DeletePatient :exec
DELETE FROM patient
WHERE id = $1
`

func (q *Queries) DeletePatient(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePatient, id)
	return err
}

const getActivePatients = `-- name: GetActivePatients :many
SELECT
  p.id,
  p.name,
  p.curr_home_id,
  p.status,
  p.journal_url,
  p.time_checkin,
  p.time_checkout,
  COALESCE(sl.name, '???') AS species,
  p.suggested_journal_title,
  p.suggested_journal_url,
  p.journal_pending
FROM patient AS p
LEFT JOIN species_language AS sl
    ON sl.species_id = p.species_id
WHERE curr_home_id IS NOT NULL
  AND language_id = $1
ORDER BY p.curr_home_id, p.sort_order, p.id
`

type GetActivePatientsRow struct {
	ID                    int32
	Name                  string
	CurrHomeID            pgtype.Int4
	Status                int32
	JournalUrl            pgtype.Text
	TimeCheckin           pgtype.Timestamptz
	TimeCheckout          pgtype.Timestamptz
	Species               string
	SuggestedJournalTitle pgtype.Text
	SuggestedJournalUrl   pgtype.Text
	JournalPending        bool
}

func (q *Queries) GetActivePatients(ctx context.Context, languageID int32) ([]GetActivePatientsRow, error) {
	rows, err := q.db.Query(ctx, getActivePatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActivePatientsRow
	for rows.Next() {
		var i GetActivePatientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrHomeID,
			&i.Status,
			&i.JournalUrl,
			&i.TimeCheckin,
			&i.TimeCheckout,
			&i.Species,
			&i.SuggestedJournalTitle,
			&i.SuggestedJournalUrl,
			&i.JournalPending,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivePatientsMissingJournal = `-- name: GetActivePatientsMissingJournal :many
SELECT 
  p.id,
  p.name,
  p.curr_home_id,
  p.status,
  p.journal_url,
  p.time_checkin,
  p.time_checkout,
  COALESCE(sl.name, '???') AS species,
  p.suggested_journal_title,
  p.suggested_journal_url
FROM patient AS p
LEFT JOIN species_language AS sl
    ON sl.species_id = p.species_id
WHERE curr_home_id IS NOT NULL
  AND language_id = $1
  AND (suggested_journal_title IS NULL OR suggested_journal_url IS NULL)
  AND (journal_url IS NULL OR journal_url='') 
  AND NOT journal_pending
ORDER BY p.curr_home_id, p.sort_order, p.id
`

type GetActivePatientsMissingJournalRow struct {
	ID                    int32
	Name                  string
	CurrHomeID            pgtype.Int4
	Status                int32
	JournalUrl            pgtype.Text
	TimeCheckin           pgtype.Timestamptz
	TimeCheckout          pgtype.Timestamptz
	Species               string
	SuggestedJournalTitle pgtype.Text
	SuggestedJournalUrl   pgtype.Text
}

func (q *Queries) GetActivePatientsMissingJournal(ctx context.Context, languageID int32) ([]GetActivePatientsMissingJournalRow, error) {
	rows, err := q.db.Query(ctx, getActivePatientsMissingJournal, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActivePatientsMissingJournalRow
	for rows.Next() {
		var i GetActivePatientsMissingJournalRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrHomeID,
			&i.Status,
			&i.JournalUrl,
			&i.TimeCheckin,
			&i.TimeCheckout,
			&i.Species,
			&i.SuggestedJournalTitle,
			&i.SuggestedJournalUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentPatientsForHome = `-- name: GetCurrentPatientsForHome :many
SELECT p.id, p.species_id, p.curr_home_id, p.name, p.status, p.journal_url, p.sort_order, p.time_checkin, p.time_checkout, p.suggested_journal_url, p.suggested_journal_title, p.journal_pending, sl.name AS species_name FROM patient AS p
JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE p.curr_home_id = $1
  AND sl.language_id = $2
ORDER BY p.sort_order, p.id
`

type GetCurrentPatientsForHomeParams struct {
	CurrHomeID pgtype.Int4
	LanguageID int32
}

type GetCurrentPatientsForHomeRow struct {
	ID                    int32
	SpeciesID             int32
	CurrHomeID            pgtype.Int4
	Name                  string
	Status                int32
	JournalUrl            pgtype.Text
	SortOrder             int32
	TimeCheckin           pgtype.Timestamptz
	TimeCheckout          pgtype.Timestamptz
	SuggestedJournalUrl   pgtype.Text
	SuggestedJournalTitle pgtype.Text
	JournalPending        bool
	SpeciesName           string
}

func (q *Queries) GetCurrentPatientsForHome(ctx context.Context, arg GetCurrentPatientsForHomeParams) ([]GetCurrentPatientsForHomeRow, error) {
	rows, err := q.db.Query(ctx, getCurrentPatientsForHome, arg.CurrHomeID, arg.LanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrentPatientsForHomeRow
	for rows.Next() {
		var i GetCurrentPatientsForHomeRow
		if err := rows.Scan(
			&i.ID,
			&i.SpeciesID,
			&i.CurrHomeID,
			&i.Name,
			&i.Status,
			&i.JournalUrl,
			&i.SortOrder,
			&i.TimeCheckin,
			&i.TimeCheckout,
			&i.SuggestedJournalUrl,
			&i.SuggestedJournalTitle,
			&i.JournalPending,
			&i.SpeciesName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFormerPatients = `-- name: GetFormerPatients :many
SELECT
  p.id,
  p.name,
  p.curr_home_id,
  p.status,
  p.journal_url,
  p.time_checkin,
  p.time_checkout,
  COALESCE(sl.name, '???') AS species,
  p.suggested_journal_title,
  p.suggested_journal_url,
  p.journal_pending
FROM patient AS p
LEFT JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE curr_home_id IS NULL
  AND sl.language_id = $1
ORDER BY p.time_checkout DESC
`

type GetFormerPatientsRow struct {
	ID                    int32
	Name                  string
	CurrHomeID            pgtype.Int4
	Status                int32
	JournalUrl            pgtype.Text
	TimeCheckin           pgtype.Timestamptz
	TimeCheckout          pgtype.Timestamptz
	Species               string
	SuggestedJournalTitle pgtype.Text
	SuggestedJournalUrl   pgtype.Text
	JournalPending        bool
}

func (q *Queries) GetFormerPatients(ctx context.Context, languageID int32) ([]GetFormerPatientsRow, error) {
	rows, err := q.db.Query(ctx, getFormerPatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFormerPatientsRow
	for rows.Next() {
		var i GetFormerPatientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrHomeID,
			&i.Status,
			&i.JournalUrl,
			&i.TimeCheckin,
			&i.TimeCheckout,
			&i.Species,
			&i.SuggestedJournalTitle,
			&i.SuggestedJournalUrl,
			&i.JournalPending,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatient = `-- name: GetPatient :one
SELECT id, species_id, curr_home_id, name, status, journal_url, sort_order, time_checkin, time_checkout, suggested_journal_url, suggested_journal_title, journal_pending FROM patient
WHERE id = $1
`

func (q *Queries) GetPatient(ctx context.Context, id int32) (Patient, error) {
	row := q.db.QueryRow(ctx, getPatient, id)
	var i Patient
	err := row.Scan(
		&i.ID,
		&i.SpeciesID,
		&i.CurrHomeID,
		&i.Name,
		&i.Status,
		&i.JournalUrl,
		&i.SortOrder,
		&i.TimeCheckin,
		&i.TimeCheckout,
		&i.SuggestedJournalUrl,
		&i.SuggestedJournalTitle,
		&i.JournalPending,
	)
	return i, err
}

const getPatientWithSpecies = `-- name: GetPatientWithSpecies :one
SELECT p.id, p.species_id, p.curr_home_id, p.name, p.status, p.journal_url, p.sort_order, p.time_checkin, p.time_checkout, p.suggested_journal_url, p.suggested_journal_title, p.journal_pending, sl.name AS species_name FROM patient AS p
JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE p.id = $1
  AND sl.language_id = $2
`

type GetPatientWithSpeciesParams struct {
	ID         int32
	LanguageID int32
}

type GetPatientWithSpeciesRow struct {
	ID                    int32
	SpeciesID             int32
	CurrHomeID            pgtype.Int4
	Name                  string
	Status                int32
	JournalUrl            pgtype.Text
	SortOrder             int32
	TimeCheckin           pgtype.Timestamptz
	TimeCheckout          pgtype.Timestamptz
	SuggestedJournalUrl   pgtype.Text
	SuggestedJournalTitle pgtype.Text
	JournalPending        bool
	SpeciesName           string
}

func (q *Queries) GetPatientWithSpecies(ctx context.Context, arg GetPatientWithSpeciesParams) (GetPatientWithSpeciesRow, error) {
	row := q.db.QueryRow(ctx, getPatientWithSpecies, arg.ID, arg.LanguageID)
	var i GetPatientWithSpeciesRow
	err := row.Scan(
		&i.ID,
		&i.SpeciesID,
		&i.CurrHomeID,
		&i.Name,
		&i.Status,
		&i.JournalUrl,
		&i.SortOrder,
		&i.TimeCheckin,
		&i.TimeCheckout,
		&i.SuggestedJournalUrl,
		&i.SuggestedJournalTitle,
		&i.JournalPending,
		&i.SpeciesName,
	)
	return i, err
}

const getPatientsByJournalURL = `-- name: GetPatientsByJournalURL :many
SELECT
  p.id
FROM patient AS p
WHERE p.journal_url LIKE CONCAT('%', $1::TEXT, '%')
`

func (q *Queries) GetPatientsByJournalURL(ctx context.Context, lookup string) ([]int32, error) {
	rows, err := q.db.Query(ctx, getPatientsByJournalURL, lookup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const movePatient = `-- name: MovePatient :exec
UPDATE patient
SET curr_home_id = $2
WHERE id = $1
`

type MovePatientParams struct {
	ID         int32
	CurrHomeID pgtype.Int4
}

func (q *Queries) MovePatient(ctx context.Context, arg MovePatientParams) error {
	_, err := q.db.Exec(ctx, movePatient, arg.ID, arg.CurrHomeID)
	return err
}

const setPatientJournal = `-- name: SetPatientJournal :execresult
UPDATE patient
SET journal_url=$2, journal_pending=FALSE
WHERE id = $1
`

type SetPatientJournalParams struct {
	ID         int32
	JournalUrl pgtype.Text
}

func (q *Queries) SetPatientJournal(ctx context.Context, arg SetPatientJournalParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, setPatientJournal, arg.ID, arg.JournalUrl)
}

const setPatientJournalNotPendingIfOlderThan5Minutes = `-- name: SetPatientJournalNotPendingIfOlderThan5Minutes :execresult
UPDATE patient
SET journal_pending = FALSE
WHERE journal_pending AND time_checkin < NOW() - INTERVAL '5 minutes'
`

func (q *Queries) SetPatientJournalNotPendingIfOlderThan5Minutes(ctx context.Context) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, setPatientJournalNotPendingIfOlderThan5Minutes)
}

const setPatientJournalPending = `-- name: SetPatientJournalPending :exec
UPDATE patient
SET journal_pending=$2
WHERE id = $1
`

type SetPatientJournalPendingParams struct {
	ID             int32
	JournalPending bool
}

func (q *Queries) SetPatientJournalPending(ctx context.Context, arg SetPatientJournalPendingParams) error {
	_, err := q.db.Exec(ctx, setPatientJournalPending, arg.ID, arg.JournalPending)
	return err
}

const setPatientName = `-- name: SetPatientName :exec
UPDATE patient
SET name = $2
WHERE id = $1
`

type SetPatientNameParams struct {
	ID   int32
	Name string
}

func (q *Queries) SetPatientName(ctx context.Context, arg SetPatientNameParams) error {
	_, err := q.db.Exec(ctx, setPatientName, arg.ID, arg.Name)
	return err
}

const setPatientSpecies = `-- name: SetPatientSpecies :exec
UPDATE patient
SET species_id = $2
WHERE id = $1
`

type SetPatientSpeciesParams struct {
	ID        int32
	SpeciesID int32
}

func (q *Queries) SetPatientSpecies(ctx context.Context, arg SetPatientSpeciesParams) error {
	_, err := q.db.Exec(ctx, setPatientSpecies, arg.ID, arg.SpeciesID)
	return err
}

const setPatientStatus = `-- name: SetPatientStatus :exec
UPDATE patient
SET status = $2
WHERE id = $1
`

type SetPatientStatusParams struct {
	ID     int32
	Status int32
}

func (q *Queries) SetPatientStatus(ctx context.Context, arg SetPatientStatusParams) error {
	_, err := q.db.Exec(ctx, setPatientStatus, arg.ID, arg.Status)
	return err
}

const suggestJournal = `-- name: SuggestJournal :exec
UPDATE patient
SET suggested_journal_url = $1, suggested_journal_title = $2
WHERE id = $3
`

type SuggestJournalParams struct {
	Url   pgtype.Text
	Title pgtype.Text
	ID    int32
}

func (q *Queries) SuggestJournal(ctx context.Context, arg SuggestJournalParams) error {
	_, err := q.db.Exec(ctx, suggestJournal, arg.Url, arg.Title, arg.ID)
	return err
}

const updatePatientSortOrder = `-- name: UpdatePatientSortOrder :exec
UPDATE patient as p
SET sort_order = v.sort_order
FROM (
  SELECT UNNEST($1::int[]) AS id,
         UNNEST($2::int[]) AS sort_order
) AS v
WHERE p.id = v.id
`

type UpdatePatientSortOrderParams struct {
	Ids    []int32
	Orders []int32
}

func (q *Queries) UpdatePatientSortOrder(ctx context.Context, arg UpdatePatientSortOrderParams) error {
	_, err := q.db.Exec(ctx, updatePatientSortOrder, arg.Ids, arg.Orders)
	return err
}
